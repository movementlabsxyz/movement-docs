---
title: Encode submission
full: true
_openapi:
  method: POST
  route: /transactions/encode_submission
  toc: []
  structuredData:
    headings: []
    contents:
      - content: >-
          This endpoint accepts an EncodeSubmissionRequest, which internally is
          a

          UserTransactionRequestInner (and optionally secondary signers) encoded

          as JSON, validates the request format, and then returns that request

          encoded in BCS. The client can then use this to create a transaction

          signature to be used in a SubmitTransactionRequest, which it then

          passes to the /transactions POST endpoint.


          To be clear, this endpoint makes it possible to submit transaction

          requests to the API from languages that do not have library support
          for

          BCS. If you are using an SDK that has BCS support, such as the
          official

          Rust, TypeScript, or Python SDKs, you do not need to use this
          endpoint.


          To sign a message using the response from this endpoint:

          - Decode the hex encoded string in the response to bytes.

          - Sign the bytes to create the signature.

          - Use that as the signature field in something like Ed25519Signature,
          which you then use to build a TransactionSignature.
---

{/* This file was generated by Fumadocs. Do not edit this file directly. Any changes should be made by running the generation command again. */}

This endpoint accepts an EncodeSubmissionRequest, which internally is a
UserTransactionRequestInner (and optionally secondary signers) encoded
as JSON, validates the request format, and then returns that request
encoded in BCS. The client can then use this to create a transaction
signature to be used in a SubmitTransactionRequest, which it then
passes to the /transactions POST endpoint.

To be clear, this endpoint makes it possible to submit transaction
requests to the API from languages that do not have library support for
BCS. If you are using an SDK that has BCS support, such as the official
Rust, TypeScript, or Python SDKs, you do not need to use this endpoint.

To sign a message using the response from this endpoint:
- Decode the hex encoded string in the response to bytes.
- Sign the bytes to create the signature.
- Use that as the signature field in something like Ed25519Signature, which you then use to build a TransactionSignature.

<APIPage document={"content/docs/api/spec.yaml"} operations={[{"path":"/transactions/encode_submission","method":"post"}]} webhooks={[]} hasHead={false} />