---
id: node-level-architecture
title: Node-Level Architecture
description: "Detailed node-level architecture and components"
---

This document provides a detailed view of the internal architecture of Movement L1 nodes, covering the various components, their interactions, and the data flows within a single node instance. For the high-level system architecture and network design, see [L1 Architecture](/general/l1/architecture).

## Core Layers

The Movement L1 node architecture is organized into five core layers, each handling specific aspects of node functionality while working together to provide a complete, high-performance blockchain node. These layers correspond directly to the [L1 architecture](/general/l1/architecture) but focus on the internal implementation details of individual nodes rather than the overall system design.

```
┌─────────────────────────────────────────────────────────────────────┐
│                        Movement L1 Node                             │
├─────────────────────────────────────────────────────────────────────┤
│  1. API Layer                                                       │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐                    │
│  │   RPC/API   │ │  WebSocket  │ │   Metrics   │                    │
│  │   Server    │ │   Server    │ │   Exporter  │                    │
│  └─────────────┘ └─────────────┘ └─────────────┘                    │
├─────────────────────────────────────────────────────────────────────┤
│  2. Storage Layer                                                   │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐    │
│  │   State     │ │ Transaction │ │   Event     │ │   Config    │    │
│  │   Store     │ │    Store    │ │   Store     │ │   Store     │    │
│  └─────────────┘ └─────────────┘ └─────────────┘ └─────────────┘    │
├─────────────────────────────────────────────────────────────────────┤
│  3. Execution Layer                                                 │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐                    │
│  │ Transaction │ │   Executor  │ │ State Cache │                    │
│  │  Validator  │ │   Engine    │ │   Manager   │                    │
│  └─────────────┘ └─────────────┘ └─────────────┘                    │
├─────────────────────────────────────────────────────────────────────┤
│  4. Consensus Layer                                                 │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐    │
│  │  Consensus  │ │   Voting    │ │   Leader    │ │   Safety    │    │
│  │   Engine    │ │   Module    │ │  Election   │ │   Module    │    │
│  └─────────────┘ └─────────────┘ └─────────────┘ └─────────────┘    │
├─────────────────────────────────────────────────────────────────────┤
│  5. Network Layer                                                   │
│  ┌─────────────┐ ┌─────────────┐                                    │
│  │   P2P Net   │ │   Mempool   │                                    │
│  │   Handler   │ │   Manager   │                                    │
│  └─────────────┘ └─────────────┘                                    │
└─────────────────────────────────────────────────────────────────────┘
```

### 1. API Layer

#### RPC/API Server

The RPC/API Server provides external API access to node functionality.
The RPC/API Server provides _**transaction submission**_ endpoints for submitting signed transactions to the network, _**state queries**_ for querying account states and resource data, _**block information**_ retrieval for block and transaction data, and _**network status**_ endpoints for getting node and network health information.

#### WebSocket Server

The WebSocket Server provides real-time event streaming to subscribers.
The WebSocket Server streams _**new block**_ notifications in real-time, _**transaction confirmation**_ status updates, _**account change**_ notifications for state changes, and _**network events**_ including validator set changes and other network events.

#### Metrics Exporter

The Metrics Exporter exports node performance and health metrics.
It tracks _**performance metrics**_ including transaction throughput, latency, and CPU usage, _**network metrics**_ such as peer count, message rates, and bandwidth usage, _**storage metrics**_ covering database size, disk I/O, and cache hit rates, and _**consensus metrics**_ including participation rates and voting statistics.

### 2. Storage Layer

#### State Store

The State Store provides persistent storage of global blockchain state. It supports _**efficient read operations**_ with Merkle proofs for state queries, _**atomic write operations**_ with versioning for state updates, _**proof generation**_ for cryptographic proofs of state, and _**state synchronization**_ to sync state with other nodes.

#### Transaction Store

The Transaction Store stores the complete transaction history and metadata

#### Event Store and Indexing

The Event Store provides indexing _**by event key**_ for fast queries of specific event streams, _**by type**_ to query events by Move type, _**by transaction**_ to find all events from a specific transaction, and _**by block**_ to retrieve all events from a block.

#### Configuration Store

The Configuration Store stores node configuration and network parameters.
The Configuration Store manages _**network configuration**_ for peer discovery and connection limits, _**consensus configuration**_ for voting timeouts and block limits, _**execution configuration**_ for gas prices and resource limits, and _**API configuration**_ for rate limits and authentication settings.

### 3. Execution Layer

#### Transaction Validator

The Transaction Validator validates transaction signatures, format, and basic checks in the following steps:
1. **Signature Verification**: Cryptographic signature validation
2. **Format Checking**: Transaction structure and field validation
3. **Sequence Validation**: Account sequence number verification
4. **Gas Validation**: Gas price and limit verification
5. **Balance Checking**: Sufficient balance for transaction fees

#### Executor Engine

The Executor Engine executes validated transactions using the MoveVM and through the following pipeline:
1. **Transaction Preparation**: Load account states and dependencies
2. **MoveVM Execution**: Execute Move bytecode in sandboxed environment
3. **State Updates**: Apply changes to global state
4. **Event Generation**: Generate events for state changes
5. **Gas Accounting**: Calculate and charge gas fees


#### State Cache Manager

The State Cache Manager manages in-memory caching of frequently accessed state.
The State Cache Manager maintains an _**account cache**_ for recently accessed account states, a _**resource cache**_ for frequently queried Move resources, a _**module cache**_ for compiled Move module bytecode, and a _**Merkle cache**_ for recently computed Merkle tree nodes.

### 4. Consensus Layer

#### Consensus Engine

The Consensus Engine coordinates the Byzantine Fault Tolerant consensus protocol through the following flow:
1. **Block Proposal**: Leader proposes a block containing transactions and a Quorum Certificate (QC) for its parent.
2. **Voting Phase**: Validators verify the proposal and cast _**vote messages**_.
3. **QC Formation**: Votes are aggregated into a _**Quorum Certificate**_ attesting to the block's validity.
4. **Block Commit**: Once a 3-chain of consecutive certified blocks is formed, the earliest block in the chain is _**finalized**_ and added to the ledger.

#### Voting Module

The Voting Module handles vote creation, validation, aggregation, and timeout votes for liveness. It has the following vote types:
- _**block vote**_: validator’s signature attesting to a proposed block.
- _**timeout vote**_: issued if no valid proposal is received in time, can aggregate into a Timeout Certificate (TC) to trigger a new leader view.

#### Leader Election

The Leader Election determines which validator proposes the next block.
The Leader Election uses _**weighted selection**_ with probability proportional to validator stake, ensuring _**deterministic**_ selection where the same leader is chosen by all honest validators. The algorithm implements _**regular rotation**_ to prevent centralization and guarantees _**liveness**_ with progress even when some validators are offline.

#### Safety Module

The Safety Module ensures consensus safety properties are maintained.
The Safety Module performs _**conflicting vote detection**_ to prevent double voting, _**fork detection**_ to identify potential blockchain forks, _**slashing evidence**_ collection for malicious behavior, and implements _**recovery mechanisms**_ to handle network partitions and attacks.

### 5. Network Layer

#### P2P Network Handler

The P2P Network Handler manages peer-to-peer communication with other nodes.
The P2P Network Handler consists of a _**connection manager**_ that establishes and maintains connections to peers, a _**message router**_ that routes incoming messages to appropriate handlers, a _**gossip protocol**_ that implements efficient information dissemination, and _**peer discovery**_ mechanisms that discover and connect to new network peers.

#### Mempool Manager

The Mempool Manager manages pending transactions before consensus.
The Mempool Manager includes a _**transaction pool**_ for in-memory storage of pending transactions, a _**priority queue**_ that orders transactions by gas price and priority, a _**spam filter**_ that prevents spam and invalid transactions, and an _**expiration manager**_ that removes expired transactions.

## Node Types and Specialization

#### Validator Nodes

Validator nodes provide _**active consensus participation**_ in block production, performing _**state validation**_ by verifying all state transitions and contributing to _**network security**_ through staking mechanisms. These nodes participate in _**protocol governance**_ decisions and include _**full consensus participation**_ with complete consensus engine activation, _**block production**_ capabilities for proposing and creating blocks, _**validator key management**_ for secure storage of validator keys, and _**slashing protection**_ against slashing conditions.

#### Full Nodes

Full nodes maintain _**complete state synchronization**_ of the blockchain state, providing _**transaction relay**_ services that forward transactions to the validator network and offering _**API services**_ with endpoints for applications. These nodes ensure _**data availability**_ for network participants and are configured with _**complete state synchronization**_ for state replication, _**full API services**_ with complete endpoint availability, _**real-time event streaming**_ for notifications, and _**mempool participation**_ for transaction relay and validation.

#### Light Nodes

Light nodes implement _**selective synchronization**_ by syncing only relevant account data, performing _**proof verification**_ without maintaining full state and achieving _**resource efficiency**_ with minimal storage and bandwidth requirements. These nodes provide _**mobile support**_ optimized for mobile and embedded devices, with _**reduced storage**_ requirements and _**bandwidth optimization**_ through efficient data transfer protocols.

## Performance Optimization

#### Caching Strategies

Performance optimization employs _**LRU cache**_ with Least Recently Used eviction for hot data, _**write-through cache**_ for consistent caching with persistent storage, _**bloom filters**_ for fast negative lookups of non-existent data, and _**data compression**_ for storage and network transfer efficiency.

#### Parallel Processing

The system implements _**transaction parallelization**_ for concurrent execution of independent transactions, _**I/O parallelization**_ through asynchronous disk and network operations, _**multi-threading**_ for CPU-intensive operations on multiple cores, and _**pipeline processing**_ to overlap computation and I/O operations.

#### Resource Management

Resource management includes _**memory pools**_ with pre-allocated memory for frequent operations, _**connection pooling**_ to reuse database and network connections, _**efficient garbage collection**_ for cleanup of temporary data, and _**rate limiting**_ to prevent resource exhaustion from excessive load.

## Monitoring and Diagnostics

#### Health Checks

Health checks monitor _**network connectivity**_ for peer connection status, _**consensus participation**_ including voting and block production rates, _**storage health**_ for database integrity and performance, and _**resource utilization**_ covering CPU, memory, and disk usage.

#### Logging and Tracing

The system implements _**structured logging**_ with machine-readable log formats, _**distributed tracing**_ for request tracing across components, _**performance metrics**_ with detailed timing and throughput data, and _**comprehensive error tracking**_ for error collection and analysis.

#### Debugging Tools

Debugging tools provide _**state inspection**_ capabilities for examining blockchain state, _**transaction simulation**_ for testing transaction execution, _**network analysis**_ to analyze peer connections and message flow, and _**performance profiling**_ to identify performance bottlenecks.
