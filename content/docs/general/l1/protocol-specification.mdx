---
id: protocol-specification
title: Movement L1 (M1) Protocol Specification
description: "Protocol specification for Movement L1"
---

## Abstract

Movement L1 (M1) is a blockchain infrastructure built to realize the full potential of the Move programming language. It provides a secure, resource-oriented foundation for decentralized applications, on-chain finance, and digitally native organizations.

Beyond performance and safety, M1 is designed around a simple premise: technology should empower its users. It exists to restore the values of open participation, shared ownership, and verifiable trust to a global, mobile-first economy.

This document outlines the motivation, principles, and high-level architecture of M1 - a people-centered Layer 1 network that unites the efficiency of Move with a design philosophy grounded in accessibility and community ownership.

---

## 1. Introduction

### 1.1 Background

The blockchain ecosystem has evolved through repeated attempts to resolve the tension between scalability, security, and decentralization. Each generation of networks made progress, yet the trade-offs between performance and openness have persisted. The result is a landscape defined as much by fragmentation as by innovation — a collection of specialized systems often optimized for capital, not users.

The Move programming language, originally developed for the Diem project, represents a clean break from that trend. Its resource-oriented design, type safety, and formal verification make it uniquely suited for building verifiable financial systems. M1 extends this vision to the protocol layer itself, creating a network that is both technically robust and socially aligned with the community that depends on it.

### 1.2 Vision and Motivation

Movement continues the evolution of Move-based blockchain infrastructure with a renewed focus on accessibility, community participation, and sustainable on-chain economies. Its aim is to refine existing foundations toward a more inclusive and purposeful network.

Modern blockchains often measure success primarily through market metrics such as TVL or fees. Movement shifts that focus back to user impact — to how effectively a network can empower people to build, earn, and coordinate. It transforms mature technology into open infrastructure for a real community.

A sovereign Layer 1 enables this direction. By operating its own L1, Movement can shape its economics, governance, and coordination mechanisms around inclusivity and resilience — for instance, by driving value to regional hubs through its validators. The result is a network optimized for community-scale applications, meaningful community participation, real-world assets, and mobile-native finance — a system that prioritizes usability and shared benefit over speculation.

### 1.3 Guiding Principles

Movement's development is driven by a small set of non-negotiable principles that inform every layer of the system:

1. **People first** : technology should expand agency, not enclose it.
2. **Community as infrastructure** : decentralization is not only technical; it is social.
3. **Accessibility at the edge** : the next billion users will come from mobile, developing, and bandwidth-limited environments.
4. **Composability with purpose** : protocols and applications should interconnect into a coherent economic mesh rather than isolated silos.
5. **Sustainability over speculation** : value should circulate between builders, validators, and community, forming a stable foundation for long-term growth.

### 1.4 Applications and Ecosystem

M1 is designed as a general-purpose Layer 1 that supports a wide spectrum of decentralized applications, from on-chain finance to digital identity and coordination systems. Its architecture emphasizes composability, verifiability, and predictable performance, allowing developers to build without compromising safety or accessibility.

The network's focus is on real utility rather than speculative activity. Applications that benefit most from Movement's design include:

- **Decentralized finance and asset issuance** : markets, payment rails, and credit systems where transparency and verifiable execution are essential.
- **Real-world asset integration** : Accredited financial institutions operating on the Movement network can tokenize representations of tangible assets, enabling ownership and yield to be distributed among the community in a compliant and transparent manner, rather than concentrated in custodial entities.
- **Mobile-native experiences** : lightweight clients and wallets enabling users to transact and interact directly from any device.
- **Identity and reputation frameworks** : systems for establishing trust, contribution history, and governance participation on-chain.
- **Community-driven governance and coordination** : mechanisms that allow stakeholders to propose, vote, and execute collective decisions securely.

Together, these categories define the intended shape of the Movement ecosystem: a practical, verifiable network where applications align economic value with human contribution.

### 1.5 L1 Design Philosophy

M1 is a social-technical system. Its purpose is not to create another marketplace for tokens but to establish a durable framework for coordination and ownership. The network treats every contribution — from validation to governance to development to education — as a building block of value.

In this sense, Movement is less a product than a public utility: a system where effort converts into value, contribution into ownership, and participation into collective strength.

### 1.6 L1 Key Features

M1 implements the following key features:

1. **Move Runtime**: MoveVM implementation for blockchain execution.
2. **High-Throughput Consensus**: Jolteon lineage and a Quorum Store–like dissemination layer for scaling under load.
3. **Parallel Execution**: transaction parallelization for increased throughput.
4. **State Management**: state storage and management solutions.
5. **Developer Tooling**: development environment and debugging tools.

## 2. Technical Architecture

### 2.1 System Overview

M1 employs a modular architecture with distinct layers handling different aspects of blockchain operation:

```
Application Layer    │ DApps, DeFi, NFTs, Enterprise Applications
API Layer            │ REST, WebSocket, Indexer GraphQL Interfaces
Execution Layer      │ MoveVM Runtime, Transaction Processing
Storage Layer        │ State Store, Transaction History, Events
Consensus Layer      │ BFT Consensus, Validator Network
Network Layer        │ Peer-to-peer communication, Mempool management, Message routing
```

### 2.2 Consensus Protocol

#### 2.2.1 Jolteon

M1 adopts a [Jolteon](https://arxiv.org/abs/2106.10362)-style BFT protocol. Jolteon introduces a 2-chain commit rule and a quadratic view change (pacemaker) to reduce latency and ensure fast recovery. In the happy path it achieves linear message complexity with one-round confirmations; under stress it remains robust.

The protocol guarantees _**safety**_ with consistency up to 1/3 Byzantine validators, ensures _**liveness**_ with progress under network asynchrony, provides _**finality**_ through 2-chain commit for fast confirmations, and maintains _**efficiency**_ with optimized message complexity and round duration.

#### 2.2.2 Validator Selection

The network employs Proof-of-Stake (PoS) with _**weighted selection**_ where validator selection probability is proportional to stake, a _**dynamic set**_ allowing validators to join/leave based on stake and performance, and _**rewards**_ with staking rewards for honest validation and block production. (Note: slashing is defined in protocol but not currently active.)

#### 2.2.3 Block Production

Block production follows a deterministic leader selection algorithm:

```rust
// Note: This is a simplified pseudocode representation.
// Deterministic, stake/reputation-weighted round-robin (illustrative)
fn select_leader(set: &ValidatorSet, round: u64) -> ValidatorId {
let order = set.weighted_order_by_stake_and_rep(); // fixed per epoch
order[(round as usize) % order.len()]
}
```

#### 2.2.4 Data Dissemination

[Quorum Store](https://forum.aptosfoundation.org/t/aptos-quorum-store-breaking-the-bottleneck/16671)–style dissemination: separate transaction dissemination from ordering to stabilize throughput under bursty load; bypass under low load for minimal latency.

### 2.3 Move Virtual Machine

#### 2.3.1 Runtime Optimization

M1's MoveVM implementation includes an _**optimized interpreter**_ with verified bytecode, _**instruction caching**_ for caching of compiled bytecode for repeated execution, _**gas optimization**_ with precise gas metering and minimal overhead, and _**memory management**_ with efficient memory allocation and garbage collection.

#### 2.3.2 Security Features

The MoveVM provides built-in security guarantees including _**resource safety**_ to prevent double-spending and resource leaks, _**type safety**_ with compile-time and runtime type checking, _**access control**_ with fine-grained permission management, and _**formal verification**_ support for mathematical proof of contract correctness.

#### 2.3.3 Parallel Execution

Transaction execution can be parallelized when dependencies allow (**Block-STM** approach):

```rust
// Note: This is a simplified pseudocode representation.
struct ParallelExecutor {
    worker_pool: ThreadPool,
    dependency_graph: DependencyAnalyzer,
    conflict_detector: ConflictDetector,
}

impl ParallelExecutor {
    fn execute_batch(&self, transactions: Vec<Transaction>) -> Vec<ExecutionResult> {
        let dependency_groups = self.dependency_graph.analyze(&transactions);
        let results = dependency_groups.par_iter()
            .map(|group| self.execute_group(group))
            .collect();
        self.resolve_conflicts(results)
    }
}
```

### 2.4 State Management

#### 2.4.1 Global State Model

M1 maintains a global state organized by account addresses using an _**account model**_ where each address can hold multiple resources and modules, _**resource storage**_ with native storage of Move resources and type information, _**module storage**_ for compiled Move modules with metadata, and _**versioned state**_ indexed by ledger version, with authenticated proofs via the Jellyfish Merkle Tree.

#### 2.4.2 Jellyfish Merkle Tree (JMT)

State commitment uses the Jellyfish Merkle Tree:

M1 uses a Jellyfish Merkle Tree for state commitment. This structure enables efficient proofs of state and supports scalable verification for light clients and full nodes.

```
State Root (Jellyfish Merkle Tree)
├── Account Subtree
│   ├── Address_1 → {Resources, Modules}
│   ├── Address_2 → {Resources, Modules}
│   └── ...
├── Events Subtree
│   ├── Event_Stream_1 → [Event_1, Event_2, ...]
│   └── ...
└── Metadata Subtree
    ├── Validator Set
    ├── Network Configuration
    └── ...
```

#### 2.4.3 Storage Optimization

Several optimizations improve storage efficiency including _**state pruning**_ for removal of old state versions (configurable), _**RocksDB-level compression**_ for data storage and transfer, _**indexing**_ with efficient indexing for common query patterns, and _**caching**_ with multi-level caching for frequently accessed data.

### 2.5 Network Protocol

#### 2.5.1 Peer-to-Peer Communication

Network communication uses a gossip-based protocol with _**peer discovery**_ for automatic discovery and connection to network peers, _**message routing**_ for efficient routing of messages based on type and priority, _**bandwidth optimization**_ through compression and batching of network messages, and _**security**_ with cryptographic authentication and message integrity.

#### 2.5.2 Transaction Propagation

Transaction propagation is optimized for low latency:

1. **Client Submission**: Transaction submitted to any network node
2. **Initial Validation**: Basic validation (signature, format, balance)
3. **Mempool Insertion**: Addition to local mempool if valid
4. **Gossip Protocol**: Propagation to connected peers
5. **Consensus Inclusion**: Selection for inclusion in next block

## 3. Economic Model

### 3.1 Token Economics

#### 3.1.1 MOVE Token

The native MOVE token serves multiple purposes including _**transaction fees**_ for payment of transaction execution and storage, _**staking**_ for validator staking and network security, _**governance**_ for voting on protocol upgrades and parameters, and _**incentives**_ for rewards to validators and network participants.

#### 3.1.2 Fee Structure

Transaction fees are calculated based on resource consumption:

```rust
// Note: This is a simplified pseudocode representation.
// Fee model: gas unit price × gas used, minus storage refund
struct GasSchedule {
    instruction_costs: HashMap<Opcode, Gas>,
    storage_costs: StorageGasSchedule,
}

fn calculate_fee(gas_used: Gas, gas_unit_price: Octa, storage_refund: Octa) -> Fee {
    gas_used * gas_unit_price - storage_refund
}
```

#### 3.1.3 Staking Mechanism

Validator staking follows these principles including _**minimum stake**_ requirements for validator participation, _**delegation**_ allowing token holders to delegate stake to validators, _**rewards**_ with proportional rewards based on stake and performance, and _**slashing**_ defined in protocol but not active on mainnet as of 2025.

### 3.2 Governance Model

#### 3.2.1 On-Chain Governance

Governance decisions are made through on-chain voting with _**proposal submission**_ allowing stakeholders to submit governance proposals, _**voting periods**_ with time-bounded voting on active proposals, and _**execution**_ with automatic execution of approved proposals.

#### 3.2.2 Parameter Management

Key network parameters can be adjusted through governance including _**gas prices**_ for base gas price and fee structure, _**block parameters**_ for block size, time, and transaction limits, _**staking parameters**_ for minimum stake, reward rates, and slashing conditions, and _**network configuration**_ for validator set size and consensus timeouts.

## 4. Security Analysis

### 4.1 Threat Model

#### 4.1.1 Network Attacks

Protection against various network-level attacks includes _**DDoS attacks**_ with rate limiting and traffic analysis, _**eclipse attacks**_ through peer diversity and connection management, _**sybil attacks**_ via Proof-of-Stake and identity verification, and _**long-range attacks**_ using checkpointing and weak subjectivity.

#### 4.1.2 Consensus Attacks

Safeguards against consensus-level attacks include _**nothing-at-stake**_ protection with economic penalties for equivocation, _**supermajority (≥ 2/3 voting-power capture)**_ deterrence through high economic cost and provable misbehavior penalties, _**grinding and leader manipulation**_ reduction via a deterministic stake-weighted leader schedule, and _**bribe attacks**_ prevention through accountability of votes and misbehavior proofs.

#### 4.1.3 Smart Contract Security

Move language features enhance smart contract security through a _**resource model**_ that prevents double-spending and asset duplication, _**type safety**_ with compile-time prevention of common vulnerabilities, _**access control**_ with fine-grained permission and capability systems, and _**formal verification**_ support for mathematical proofs of contract correctness.

### 4.2 Cryptographic Primitives

#### 4.2.1 Digital Signatures

M1 uses Ed25519 signatures for _**transaction authentication**_ providing proof of transaction authorization, _**validator signatures**_ for consensus vote authentication, _**message integrity**_ for P2P message authentication, and _**multi-signatures**_ via Multi-Ed25519 threshold schemes.

#### 4.2.2 Hash Functions

SHA-3 (Keccak) is used throughout the system for _**block hashing**_ with unique block identification and in the _**Jellyfish Merkle Tree**_ for authenticated state and transaction commitments. Consensus uses deterministic leader selection; there is no proof-of-work or random beacon.

### 4.3 Audit and Verification

#### 4.3.1 Code Audits

Regular independent security audits ensure system integrity covering the _**core protocol**_ including consensus and networking components, _**MoveVM implementation**_ for the virtual machine and execution engine, _**cryptographic libraries**_ for all cryptographic implementations, and _**smart contracts**_ including system contracts and modules.

#### 4.3.2 Formal Verification

Mathematical verification of critical components includes _**consensus safety**_ with formal proofs of consistency for the underlying Jolteon protocol and _**Move semantics**_ with automated verification of language safety properties through the Move Prover. Incentive economics and governance-driven upgrades are not subject to the same level of formal proof.

## 5. Development Ecosystem

### 5.1 Developer Tools

#### 5.1.1 Movement CLI

Comprehensive command-line interface:

```bash
# Note: This is a simplified pseudocode representation.
# Create new Move project
movement init my-project

# Compile Move modules
movement build

# Deploy to testnet
movement deploy --network testnet

# Run local testnet
movement node run-local

# Interact with deployed contracts
movement call --function transfer --args 0x123 100
```

#### 5.1.2 IDE Integration

Support for popular development environments:

- **VS Code Extension**: Syntax highlighting, debugging, IntelliSense
- **IntelliJ Plugin**: Full IDE support with advanced features
- **Language Server**: Language Server Protocol for editor integration
- **Web IDE**: Browser-based development environment

#### 5.1.3 Testing Framework

Comprehensive testing infrastructure:

```move
// Note: This is a simplified pseudocode representation.
#[test]
public fun test_transfer() {
    let sender = @0x1;
    let receiver = @0x2;
    let amount = 100;

    // Setup test environment
    let state = create_test_state();

    // Execute transfer
    let result = transfer(sender, receiver, amount);

    // Verify results
    assert!(result.success, 1);
    assert!(balance_of(receiver) == amount, 2);
}
```

---

*This protocol specification is a living document and will be updated as M1 continues to evolve and mature.*
