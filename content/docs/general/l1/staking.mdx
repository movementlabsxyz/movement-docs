---
id: staking
title: Staking and Delegation
description: "Understanding staking states, delegation pools, and reward distribution on M1"
---

This document explains how staking and delegation work on M1, including stake lifecycle states, delegation pools, reward distribution, and the synchronization mechanism.

## Stake States (Lifecycle)

Staked tokens progress through different states during their lifecycle:

<StakeLifecycleDiagram />

### State Descriptions

- **pending_active** — Just deposited; will become active next epoch
- **active** — Earning staking rewards
- **pending_inactive** — Delegator requested unlock; waiting for lockup to expire. Still earns rewards during the lockup duration!
- **inactive** — Lockup expired; can be withdrawn

**Key point:** `pending_inactive` still earns rewards until the lockup period ends.

## StakePool vs DelegationPool

These are two separate structs stored at the same address:

- **StakePool** — Holds actual tokens (`active`, `inactive`, `pending_active`, `pending_inactive`)
- **DelegationPool** — Tracks ownership via shares (`active_shares`, `inactive_shares` table)

Rewards are distributed to the StakePool at each epoch. To sync these rewards to the DelegationPool's share pools, call `synchronize_delegation_pool(pool_address)`. This function is automatically called during all delegation pool operations like `add_stake`, `unlock`, or `withdraw`.

<DelegationPoolDiagram />

**StakePool**

A separate struct holding actual tokens. Earns rewards from consensus. Can only have ONE owner (the delegation pool's resource account).

**DelegationPool**

The main struct containing:
- `active_shares`: a `pool_u64::Pool` tracking active stake ownership
- `inactive_shares`: a table of `pool_u64::Pool` instances for pending_inactive stake

**Why Two Structs?**

A StakePool supports only one owner. The DelegationPool wraps it to allow multiple delegators, tracking each person's ownership via shares inside `pool_u64::Pool` instances.
Think: StakePool = vault with cash. DelegationPool = ledger of who owns what percentage of that cash.

## Lazy Synchronization and Gap

The delegation_pool uses lazy synchronization — no automatic sync at epoch end.

<LazySyncDiagram />

**What Triggers Sync**

- ✅ `add_stake()` — User adding stake
- ✅ `unlock()` — User unlocking stake
- ✅ `withdraw()` — User withdrawing
- ✅ `synchronize_delegation_pool()` — Anyone can call (public)
- ❌ Epoch ends — no automatic sync

**At Epoch End**

1. Rewards go to `stake_pool.active` and `stake_pool.pending_inactive`
2. `delegation_pool` share pools are not updated (stale)
3. Commission is not calculated yet

**The Gap**

The "gap" is the amount of tokens that have not yet been accounted for in the share price and the commission. It represents unsynchronized rewards waiting to be distributed to delegators (via share price increase) and operator (via commission).

<GapDiagram />

**Implications**

- If no one interacts, rewards simply accumulate indefinitely in the StakePool
- Commission is paid in one lump sum when sync finally happens
- Operator loses compounding on commission if sync is delayed

## Stake Pool Fields

The StakePool has 4 separate coin fields:

| Field | What it contains | Earns rewards |
|-------|------------------|---------------|
| `active` | Stake participating in consensus | ✅ Yes |
| `pending_active` | Added this epoch, active next epoch | ❌ No |
| `pending_inactive` | Unlocked, waiting to be withdrawable | ✅ Yes |
| `inactive` | Ready to withdraw | ❌ No |

**Total stake** = `active` + `pending_active` + `pending_inactive` + `inactive`

## Two Shares Pools: active_shares and inactive_shares

The DelegationPool contains TWO types of `pool_u64::Pool` instances that track shares:

1. **active_shares** (`pool_u64::Pool`)
   - Tracks: `StakePool.active` + `StakePool.pending_active`
   - Gap = `(active + pending_active) - active_shares.total_coins`

2. **inactive_shares** (`Table<ObservedLockupCycle, pool_u64::Pool>`)
   - Tracks: `StakePool.pending_inactive` (until lockup expires)
   - Gap = `pending_inactive - inactive_shares[cycle].total_coins`
   - One pool per lockup cycle; when lockup ends, `pending_inactive` → `inactive`

**Why Two Pools?**

The duplication isn't redundant — it's necessary because:

- **Different lifecycles:** active can receive deposits; pending_inactive cannot
- **Multiple lockup cycles:** each cycle has its own pending_inactive pool
- **Divergent share prices:** slashing could affect one pool but not the other
- **Withdrawal timing:** only pending_inactive becomes withdrawable after lockup

A single pool would require complex per-position tracking (like NFTs).

**When Sync Happens (for each pool_u64::Pool)**

1. `gap = stake_pool_value - pool.total_coins`
2. `commission = gap × commission_rate`
3. `net = gap - commission` → share price increases
4. `pool_u64::update_total_coins(pool, stake_pool_value - commission)`
5. Operator buys shares with commission

After sync, both gaps should be ~0 (minus rounding).

## Shares vs Tokens in Delegation Pools

When staking to a delegation pool, delegators receive **SHARES** rather than holding tokens directly. Shares represent proportional ownership of the pool's total token balance. When a delegator deposits tokens, the pool mints shares at the current share price (`total_tokens / total_shares`); when withdrawing, shares are redeemed for tokens at the prevailing price.

**Key Definitions**

- **SHARES** — Unit of ownership in the pool (delegator share count stays constant)
- **SHARE PRICE** — `total_tokens / total_shares` (increases as rewards accumulate)
- **VALUE** — `shares × share_price` (a delegator's stake worth in TOKEN)

**What Happens to a Delegator After Rewards**

<SharesComparisonDiagram />

- Delegator share count stays constant (e.g., 100 shares → 100 shares)
- But share PRICE increases (e.g., 1.00 → 1.05 TOKEN/SHARE)
- So delegator VALUE increases (100 × 1.00 = 100 TOKEN → 100 × 1.05 = 105 TOKEN)

**Reward Distribution Process**

When the pool earns staking rewards:

1. **Commission deducted** — The operator's commission percentage is calculated from the gross rewards.
2. **Remainder added to pool** — The net rewards (after commission) are added to `total_tokens` while `total_shares` remains constant, causing the share price to increase.
3. **Operator mints new shares** — The operator uses their commission to buy shares at the new (post-appreciation) share price. Both `total_tokens` and `total_shares` increase proportionally, so the share price remains constant after this step.

This ordering ensures the operator cannot benefit from appreciation on rewards they didn't earn. For delegators, share count stays fixed between stake operations, but VALUE (`shares × share price`) grows as net rewards accumulate.

**Benefits**

This approach provides:

- O(1) gas cost for reward distribution
- Proportional allocation without per-account calculations
- Reduced rounding errors

**Example:** A delegator with 100 shares will, after 5% gross rewards with 10% commission, still hold 100 shares—now worth approximately 104.5 tokens (reflecting 4.5% net growth).

