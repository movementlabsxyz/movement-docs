---
title: Vector Type
description: Learn about the vector type in Move, which is a dynamic, ordered, and homogeneous collection type.
---

# Vector Type

`vector<T>` is Move's built-in collection type for storing multiple values of the same type. Think of it as a dynamic array that can grow and shrink during program execution.

## What is a Vector?

A vector is a homogeneous collection that stores elements of type `T`:
- **Dynamic size**: Can grow or shrink at runtime
- **Ordered**: Elements maintain their insertion order
- **Indexed**: Access elements by their position (0-based)
- **Homogeneous**: All elements must be the same type

## Creating Vectors

### Empty Vectors

```move
use std::vector;

let empty_numbers: vector<u64> = vector[];
let empty_addresses = vector<address>[];
let empty_with_function = vector::empty<u64>();
```

### Vectors with Initial Values

```move
let numbers = vector[1, 2, 3, 4, 5];
let addresses = vector[@0x1, @0x2, @0x3];
let single_item = vector[42u8];
```

### Type Inference

Move can often infer the vector type from context:

```move
let numbers = vector[10, 20, 30];  // Inferred as vector<u64>
let explicit: vector<u32> = vector[10, 20, 30];  // Explicit type
```

## Special Vector Types

### Byte Vectors (`vector<u8>`)

Byte vectors are commonly used for strings and binary data:

```move
// Byte strings (ASCII)
let message = b"Hello, Move!";
let empty_bytes = b"";

// Hex strings
let hex_data = x"48656C6C6F";  // "Hello" in hex
let hash = x"DEADBEEF";
```


## Common Vector Operations

### Adding Elements

```move
use std::vector;

let mut numbers = vector::empty<u64>();
vector::push_back(&mut numbers, 10);
vector::push_back(&mut numbers, 20);
vector::push_back(&mut numbers, 30);
// numbers is now [10, 20, 30]
```

### Accessing Elements

```move
let numbers = vector[10, 20, 30];

// Get element by index (returns reference)
let first = vector::borrow(&numbers, 0);  // &10
let second = vector::borrow(&numbers, 1); // &20

// Check if vector contains an element
let has_twenty = vector::contains(&numbers, &20); // true
```

### Modifying Elements

```move
let mut numbers = vector[10, 20, 30];

// Modify element at index
let element_ref = vector::borrow_mut(&mut numbers, 1);
*element_ref = 25; // numbers is now [10, 25, 30]

// Remove and return last element
let last = vector::pop_back(&mut numbers); // 30
// numbers is now [10, 25]
```

### Vector Information

```move
let numbers = vector[10, 20, 30];

// Get vector length
let length = vector::length(&numbers); // 3

// Check if empty
let is_empty = vector::is_empty(&numbers); // false

// Find element index
let (found, index) = vector::index_of(&numbers, &20); // (true, 1)
```

## Advanced Operations

### Combining Vectors

```move
let mut first = vector[1, 2, 3];
let second = vector[4, 5, 6];

// Append second vector to first
vector::append(&mut first, second);
// first is now [1, 2, 3, 4, 5, 6]
```

### Removing Elements

```move
let mut numbers = vector[10, 20, 30, 40];

// Remove element at specific index
let removed = vector::remove(&mut numbers, 1); // 20
// numbers is now [10, 30, 40]

// Swap remove (faster but changes order)
let mut items = vector[1, 2, 3, 4];
let removed = vector::swap_remove(&mut items, 1); // 2
// items is now [1, 4, 3] (last element moved to removed position)
```

### Vector Utilities

```move
let mut numbers = vector[3, 1, 4, 1, 5];

// Reverse the vector
vector::reverse(&mut numbers);
// numbers is now [5, 1, 4, 1, 3]

// Swap elements
vector::swap(&mut numbers, 0, 4);
// numbers is now [3, 1, 4, 1, 5]
```

## Practical Examples

Here are common vector usage patterns:

```move
// Managing a list of user addresses
fun add_user(users: &mut vector<address>, new_user: address) {
    if (!vector::contains(users, &new_user)) {
        vector::push_back(users, new_user);
    }
}

// Processing scores
fun calculate_average(scores: &vector<u64>): u64 {
    let sum = 0;
    let i = 0;
    let len = vector::length(scores);
    
    while (i < len) {
        sum = sum + *vector::borrow(scores, i);
        i = i + 1;
    };
    
    sum / len
}

// Working with byte data
fun create_message(): vector<u8> {
    let mut message = b"Hello, ";
    vector::append(&mut message, b"Move!");
    message // Returns b"Hello, Move!"
}
```

## Safety and Performance

### Index Bounds
Vector operations check bounds automatically:

```move
let numbers = vector[1, 2, 3];
// let item = vector::borrow(&numbers, 5); // Would abort! Index out of bounds
```

### Memory Management
Vectors automatically manage memory:
- Elements are automatically cleaned up when the vector is dropped
- No manual memory management required
- Efficient resizing as elements are added

## Summary

Vectors in Move are:
- **Dynamic collections** that can grow and shrink
- **Type-safe** - all elements must be the same type
- **Indexed** - access elements by position (0-based)
- **Bounds-checked** - operations abort on invalid indices
- **Memory-safe** - automatic cleanup and management

Common use cases include:
- Storing lists of addresses, IDs, or other data
- Managing collections that change size during execution
- Working with byte data and strings
- Building more complex data structures

Vectors are essential for most Move programs that need to work with collections of data.