---
title: Coin (Legacy)
description: Learn about the legacy Coin standard for fungible token development on Movement
---

# Coin (Legacy Standard)

The [Coin standard](https://github.com/movementlabsxyz/aptos-core/blob/main/aptos-move/framework/aptos-framework/sources/coin.move) provides a robust, type-safe framework for creating fungible tokens on Movement. Built on Move's phantom type system, it enables developers to create distinct coin types while leveraging shared infrastructure.

<Callout type="info">
The Coin standard is available in the Movement framework at `0x1::coin`.
</Callout>

<Callout type="warning">
This is the legacy coin standard. For new projects on Movement, consider using the updated [Fungible Asset Standard](/docs/devs/tokenStandard/fungibleAsset/) which offers enhanced features and better composability.
</Callout>

## Overview

Movement's Coin standard enables developers to:

- **Create Type-Safe Tokens**: Each coin type is distinct at compile time, preventing accidental mixing
- **Leverage Shared Infrastructure**: Reuse proven code patterns across different token implementations
- **Integrate with Movement Ecosystem**: Native compatibility with Movement's DeFi protocols and wallets
- **Scale Efficiently**: Built-in support for high-throughput operations and parallel execution
- **Maintain Security**: Capability-based access control for critical operations

## Core Architecture

### Reusable Token Framework

The fundamental `Coin` struct uses phantom types to support multiple distinct tokens:

```move
module 0x1::coin {
  struct Coin<phantom CoinType> has store {
    /// Amount of coin this address has.
    value: u64,
  }
}
```

**Key Benefits:**
- **Type Safety**: `Coin<MOVE>` and `Coin<USDC>` are completely different types
- **Code Reuse**: Single implementation supports unlimited token types
- **Storage Efficiency**: Minimal on-chain footprint per token instance
- **Composability**: Easy integration with other Move modules and protocols

### Account Storage

Movement stores coins in user accounts using the `CoinStore` resource:

```move
module 0x1::coin {
  struct CoinStore<phantom CoinType> has key {
    coin: Coin<CoinType>,
    frozen: bool,
    deposit_events: EventHandle<DepositEvent>,
    withdraw_events: EventHandle<WithdrawEvent>,
  }
}
```

### Token Metadata

Token information and metadata are stored under the creator's account:

```move
module 0x1::coin {
  struct CoinInfo<phantom CoinType> has key {
    name: string::String,
    /// Symbol of the coin, usually a shorter version of the name.
    /// For example, Movement Token is MOVE.
    symbol: string::String,
    /// Number of decimals used to get its user representation.
    /// For example, if `decimals` equals `8`, a balance of `100000000` coins should
    /// be displayed to a user as `1.00000000` (`100000000 / 10 ** 8`).
    decimals: u8,
    /// Amount of this coin type in existence.
    supply: Option<OptionalAggregator>,
  }
}
```

## Movement Framework Structures

The following tables describe the core structures in Movement's coin implementation. For the complete reference, see the [Movement Framework Documentation](https://docs.movementlabs.xyz).

### [`Coin<CoinType>`]

| Field   | Type | Description                                    |
| ------- | ---- | ---------------------------------------------- |
| `value` | u64  | Token amount (e.g., 1000000000 for 10.00 MOVE) |

### [`CoinStore<CoinType>`]

| Field              | Type                          | Description                                      |
| ------------------ | ----------------------------- | ------------------------------------------------ |
| `coin`             | `Coin<CoinType>`             | The actual coin balance held in the store        |
| `frozen`           | bool                          | Whether deposits and withdrawals are frozen      |
| `deposit_events`   | `EventHandle<DepositEvent>`   | Event handle for tracking deposits               |
| `withdraw_events`  | `EventHandle<WithdrawEvent>`  | Event handle for tracking withdrawals            |

### [`CoinInfo<CoinType>`]

| Field      | Type                            | Description                                                                                                                      |
| ---------- | ------------------------------- | -------------------------------------------------------------------------------------------------------------------------------- |
| `name`     | String                          | Full token name (e.g., "Movement Token")                                                                                        |
| `symbol`   | String                          | Token symbol (e.g., "MOVE")                                                                                                     |
| `decimals` | u8                              | Decimal precision; MOVE uses 8 decimals, so 100000000 represents 1.00000000 MOVE                                               |
| `supply`   | `Option<OptionalAggregator>`    | Optional supply tracking for monitoring total tokens in circulation                                                              |

## Token Operations

Movement's coin standard provides comprehensive functionality for both token creators and users.

### For Token Creators

Token creators have privileged access to manage their tokens through capabilities.

#### Initialize a New Token

Create and register a new token type on Movement:

```move
module 0x1::coin {
  public fun initialize<CoinType>(
    account: &signer,
    name: string::String,
    symbol: string::String,
    decimals: u8,
    monitor_supply: bool,
  ): (BurnCapability<CoinType>, FreezeCapability<CoinType>, MintCapability<CoinType>) {
    // Implementation details...
  }
}
```

**Example: Creating a Movement-based Token**
```move
// Define your token type
struct MovementUSD {}

// Initialize the token
public fun initialize_movement_usd(creator: &signer) {
    let (burn_cap, freeze_cap, mint_cap) = coin::initialize<MovementUSD>(
        creator,
        string::utf8(b"Movement USD"),
        string::utf8(b"mUSD"),
        6, // 6 decimal places for USD precision
        true // Monitor supply for transparency
    );
    
    // Store capabilities securely
    move_to(creator, TokenCapabilities {
        burn_cap,
        freeze_cap,
        mint_cap
    });
}
```

**Requirements:**
- Must be called from the account that deployed the token module
- Token name ≤ 32 characters
- Token symbol ≤ 32 characters
- Decimals ≤ 32 (typically 6-18 for most tokens)
- Can only be initialized once per token type

#### Mint New Tokens

Create new tokens and add them to circulation:

```move
module 0x1::coin {
  public fun mint<CoinType>(
    amount: u64,
    _cap: &MintCapability<CoinType>,
  ): Coin<CoinType> {
    // Implementation...
  }
}
```

**Example Usage:**
```move
// Mint tokens for initial distribution
public fun mint_musd_for_liquidity(
    amount: u64, 
    mint_cap: &MintCapability<MovementUSD>
): Coin<MovementUSD> {
    coin::mint<MovementUSD>(amount, mint_cap)
}

// Mint and directly deposit to recipient
public fun airdrop_musd(
    recipient: address, 
    amount: u64, 
    mint_cap: &MintCapability<MovementUSD>
) {
    let tokens = coin::mint<MovementUSD>(amount, mint_cap);
    coin::deposit<MovementUSD>(recipient, tokens);
}
```

#### Burn Tokens

Remove tokens from circulation permanently:

```move
module 0x1::coin {
  public fun burn<CoinType>(
    coin: Coin<CoinType>,
    _cap: &BurnCapability<CoinType>,
  ) {
    // Implementation...
  }
  
  public fun burn_from<CoinType>(
    account_addr: address,
    amount: u64,
    burn_cap: &BurnCapability<CoinType>,
  ) {
    // Implementation...
  }
}
```

<Callout type="info">
**burn vs burn_from**

The `burn` function destroys tokens from a `Coin` struct, while `burn_from` removes tokens directly from a user's `CoinStore`. The `burn_from` function bypasses frozen status and is commonly used for transaction fees on Movement.
</Callout>

#### Freeze/Unfreeze Accounts

Control token transfers for compliance or security:

```move
module 0x1::coin {
  public entry fun freeze_coin_store<CoinType>(
    account_addr: address,
    _freeze_cap: &FreezeCapability<CoinType>,
  ) {
    // Implementation...
  }
  
  public entry fun unfreeze_coin_store<CoinType>(
    account_addr: address,
    _freeze_cap: &FreezeCapability<CoinType>,
  ) {
    // Implementation...
  }
}
```

### For Token Users

Regular users can interact with tokens through standard operations.

#### Register for Token

Prepare account to receive a specific token type:

```move
module 0x1::coin {
  public fun register<CoinType>(account: &signer) {
    // Implementation...
  }
}
```

**Example:**
```move
// Register to receive Movement USD
public entry fun register_for_musd(user: &signer) {
    coin::register<MovementUSD>(user);
}
```

#### Transfer Tokens

Send tokens between accounts on Movement:

```move
module 0x1::coin {
  public entry fun transfer<CoinType>(
    from: &signer,
    to: address,
    amount: u64,
  ) {
    // Implementation...
  }
}
```

<Callout type="info">
This operation emits both `WithdrawEvent` and `DepositEvent` for complete transaction tracking on Movement.
</Callout>

#### Advanced Token Operations

Movement provides additional utilities for token manipulation:

```move
// Merge two token amounts
public fun merge<CoinType>(
    dst_coin: &mut Coin<CoinType>,
    source_coin: Coin<CoinType>,
)

// Extract specific amount from tokens
public fun extract<CoinType>(
    coin: &mut Coin<CoinType>,
    amount: u64,
): Coin<CoinType>

// Withdraw tokens from account
public fun withdraw<CoinType>(
    account: &signer,
    amount: u64,
): Coin<CoinType>

// Deposit tokens to account
public fun deposit<CoinType>(
    account_addr: address,
    coin: Coin<CoinType>,
)
```

## Movement-Specific Features

### High-Performance Execution

Movement's coin standard is optimized for high-throughput scenarios:

- **Parallel Execution**: Multiple token operations can execute simultaneously
- **Optimized Storage**: Efficient on-chain data structures minimize gas costs
- **Batch Operations**: Support for processing multiple transfers in single transactions

### Cross-Chain Compatibility

Tokens created with Movement's coin standard can:

- **Bridge to Ethereum**: Native support for cross-chain token transfers
- **Integrate with Movement DeFi**: Seamless compatibility with DEXs, lending protocols, and yield farms
- **Support Multiple Standards**: Interoperate with both legacy coins and modern fungible assets

### Developer Tools

Movement provides enhanced tooling for coin development:

```move
// Query functions for token information
public fun balance<CoinType>(owner: address): u64
public fun supply<CoinType>(): Option<u128>
public fun name<CoinType>(): string::String
public fun symbol<CoinType>(): string::String
public fun decimals<CoinType>(): u8

// Utility functions
public fun is_account_registered<CoinType>(account: address): bool
public fun is_coin_store_frozen<CoinType>(account: address): bool
public fun value<CoinType>(coin: &Coin<CoinType>): u64
```

## Events and Monitoring

Movement's coin standard emits comprehensive events for tracking:

```move
/// Emitted when tokens are deposited to an account
struct DepositEvent has drop, store {
    amount: u64,
}

/// Emitted when tokens are withdrawn from an account  
struct WithdrawEvent has drop, store {
    amount: u64,
}
```

## Migration Path

For projects using the legacy coin standard on Movement:

1. **Assessment**: Evaluate current token usage and requirements
2. **Planning**: Design migration strategy to Fungible Asset Standard
3. **Testing**: Thoroughly test new implementation on Movement testnet
4. **Deployment**: Execute migration with minimal user disruption
5. **Monitoring**: Track performance improvements and user adoption

<Callout type="info">
Movement Labs provides migration tools and support for projects transitioning from the legacy coin standard. Contact the Movement developer relations team for assistance.
</Callout>

## Best Practices for Movement

### Security Considerations
- **Capability Management**: Store mint/burn/freeze capabilities in secure, access-controlled modules
- **Supply Monitoring**: Enable supply tracking for transparency and auditing
- **Event Logging**: Implement comprehensive event emission for all token operations
- **Testing**: Use Movement's testing framework for thorough validation

### Performance Optimization
- **Batch Operations**: Group multiple token operations when possible
- **Parallel Execution**: Design token logic to support Movement's parallel execution model
- **Storage Efficiency**: Minimize on-chain storage requirements
- **Gas Optimization**: Use Movement's gas estimation tools for cost-effective operations

### Ecosystem Integration
- **Standard Compliance**: Follow Movement's token standards for maximum compatibility
- **DeFi Integration**: Design tokens for seamless DeFi protocol integration
- **Cross-Chain Support**: Consider bridge compatibility from the design phase
- **User Experience**: Implement user-friendly interfaces for token interactions

