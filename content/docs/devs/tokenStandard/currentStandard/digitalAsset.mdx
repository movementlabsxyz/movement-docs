---
title: Digital Asset
description: Learn about the Digital Asset standard for creating and managing NFTs on Movement
---

# Digital Asset (DA) Standard

The Movement Digital Asset Standard provides a modern, flexible framework for creating and managing Non-Fungible Tokens (NFTs) on Movement. Built on Move Objects, this standard offers enhanced composability, direct transfers, and extensibility that surpasses traditional NFT implementations.

<Callout type="info">
The Digital Asset standard is available in the Movement framework at `aptos_token_objects` and represents the current standard for NFT development on Movement.
</Callout>

## Overview

Movement's Digital Asset standard enables developers to:

- **Create Sophisticated NFTs**: Build tokens with custom logic, metadata, and behaviors
- **Direct Transfers**: Transfer NFTs without recipient opt-in requirements
- **Enhanced Composability**: NFTs can own other NFTs and complex asset structures
- **Extensible Design**: Leverage Move Objects for unlimited customization possibilities
- **Ecosystem Integration**: Seamless compatibility with Movement's DeFi and gaming protocols

## Core Architecture

### Object-Based Design

The DA standard uses Move Objects to represent digital assets with two primary components:

```move
module aptos_token_objects::collection {
    /// Collection metadata and configuration
    struct Collection has key {
        creator: address,
        description: String,
        name: String,
        uri: String,
        mutation_setting: MutationSetting,
    }
}

module aptos_token_objects::token {
    /// Individual token within a collection
    struct Token has key {
        collection: Object<Collection>,
        description: String,
        name: String,
        uri: String,
        mutation_setting: MutationSetting,
    }
}
```

**Architecture Benefits:**
- **True Ownership**: NFTs are owned objects, not account resources
- **Composability**: Objects can contain other objects for complex structures
- **Extensibility**: Add custom resources and functionality via smart contracts
- **Gas Efficiency**: Optimized storage and transfer mechanisms

### Movement Framework Structures

#### Collections

Collections organize related NFTs under a unified framework:

| Field           | Type           | Description                                           |
| --------------- | -------------- | ----------------------------------------------------- |
| `creator`       | address        | Address of the collection creator                     |
| `description`   | String         | Collection description (max 2048 characters)         |
| `name`          | String         | Unique collection name under creator                  |
| `uri`           | String         | URI pointing to collection metadata (max 512 chars)  |
| `mutation_setting` | MutationSetting | Controls which fields can be modified              |

#### Tokens

Individual NFTs within collections:

| Field           | Type              | Description                                        |
| --------------- | ----------------- | -------------------------------------------------- |
| `collection`    | `Object<Collection>` | Reference to parent collection                    |
| `description`   | String            | Token description (max 2048 characters)          |
| `name`          | String            | Unique token name within collection               |
| `uri`           | String            | URI pointing to token metadata (max 512 chars)   |
| `mutation_setting` | MutationSetting | Controls which fields can be modified           |

## Creating Collections on Movement

### Fixed Supply Collections

Create collections with a predetermined maximum supply:

```move
module movement_addr::movement_nft_collection {
    use aptos_token_objects::collection;
    use aptos_token_objects::royalty;
    use std::string;
    use std::option;
    use std::signer;

    /// Movement Gaming NFT Collection
    struct MovementGamingCollection has key {}

    /// Create a Movement gaming collection with fixed supply
    public entry fun create_gaming_collection(creator: &signer) {
        let royalty_config = royalty::create(
            5, // 5% royalty
            100, // denominator
            signer::address_of(creator) // royalty recipient
        );

        collection::create_fixed_collection(
            creator,
            string::utf8(b"Exclusive collection of Movement gaming assets featuring unique characters, weapons, and items for the Movement ecosystem"),
            1000, // Maximum 1000 NFTs
            string::utf8(b"Movement Gaming Assets"),
            option::some(royalty_config),
            string::utf8(b"https://gaming.movement.xyz/collection/metadata")
        );
    }
}
```

### Unlimited Supply Collections

Create collections without supply restrictions:

```move
module movement_addr::movement_art_collection {
    use aptos_token_objects::collection;
    use aptos_token_objects::royalty;
    use std::string;
    use std::option;

    /// Create Movement art collection with unlimited supply
    public entry fun create_art_collection(creator: &signer) {
        let royalty_config = royalty::create(
            10, // 10% royalty for artists
            100,
            signer::address_of(creator)
        );

        collection::create_unlimited_collection(
            creator,
            string::utf8(b"Curated digital art collection showcasing the creativity and innovation of the Movement community"),
            string::utf8(b"Movement Digital Art"),
            option::some(royalty_config),
            string::utf8(b"https://art.movement.xyz/collection")
        );
    }
}
```

### Advanced Collection with Custom Features

Create collections with Movement-specific functionality:

```move
module movement_addr::advanced_movement_collection {
    use aptos_token_objects::collection::{Self, MutatorRef};
    use aptos_token_objects::royalty;
    use aptos_framework::object::{Self, Object};
    use aptos_framework::timestamp;
    use aptos_framework::event;
    use std::string;
    use std::option;
    use std::signer;
    use std::vector;

    /// Advanced Movement collection with custom features
    struct MovementAdvancedCollection has key {
        mutator_ref: MutatorRef,
        launch_time: u64,
        mint_phases: vector<MintPhase>,
        total_minted: u64,
    }

    /// Mint phase configuration
    struct MintPhase has store, drop {
        name: String,
        start_time: u64,
        end_time: u64,
        max_mints: u64,
        price: u64,
        whitelist_only: bool,
    }

    #[event]
    struct CollectionPhaseStarted has drop, store {
        collection: address,
        phase_name: String,
        start_time: u64,
    }

    /// Create advanced collection with phased minting
    public entry fun create_advanced_collection(
        creator: &signer,
        phases: vector<MintPhase>
    ) {
        let royalty_config = royalty::create(7, 100, signer::address_of(creator));
        
        let constructor_ref = &collection::create_unlimited_collection(
            creator,
            string::utf8(b"Premium Movement NFT collection with advanced features including phased minting, whitelist access, and dynamic pricing"),
            string::utf8(b"Movement Premium Collection"),
            option::some(royalty_config),
            string::utf8(b"https://premium.movement.xyz/metadata")
        );

        // Generate mutator ref for collection updates
        let mutator_ref = collection::generate_mutator_ref(constructor_ref);
        let collection_signer = &object::generate_signer(constructor_ref);

        // Store advanced collection data
        move_to(collection_signer, MovementAdvancedCollection {
            mutator_ref,
            launch_time: timestamp::now_seconds(),
            mint_phases: phases,
            total_minted: 0,
        });
    }

    /// Update collection for new mint phase
    public entry fun start_mint_phase(
        creator: &signer,
        collection: `Object<collection::Collection>`,
        phase_index: u64
    ) acquires MovementAdvancedCollection {
        let collection_addr = object::object_address(&collection);
        let advanced_collection = borrow_global_mut<MovementAdvancedCollection>(collection_addr);
        
        assert!(phase_index < vector::length(&advanced_collection.mint_phases), 1);
        let phase = vector::borrow(&advanced_collection.mint_phases, phase_index);
        
        // Update collection URI for the new phase
        collection::set_uri(
            &advanced_collection.mutator_ref,
            string::utf8(b"https://premium.movement.xyz/phase/metadata")
        );

        event::emit(CollectionPhaseStarted {
            collection: collection_addr,
            phase_name: phase.name,
            start_time: timestamp::now_seconds(),
        });
    }
}
```

## Creating Tokens (NFTs)

### Named Tokens

Create tokens with deterministic addresses:

```move
module movement_addr::movement_character_nft {
    use aptos_token_objects::token;
    use aptos_token_objects::royalty;
    use std::string;
    use std::option;

    /// Create a Movement character NFT
    public entry fun mint_character(
        creator: &signer,
        character_class: String,
        rarity: String,
        power_level: u64
    ) {
        let character_name = string::utf8(b"Movement Warrior #1001");
        
        let description = string::utf8(b"A powerful legendary warrior from the Movement universe with high power level");

        let royalty_config = royalty::create(5, 100, signer::address_of(creator));

        token::create_named_token(
            creator,
            string::utf8(b"Movement Gaming Assets"),
            description,
            character_name,
            option::some(royalty_config),
            string::utf8(b"https://gaming.movement.xyz/characters/warrior")
        );
    }

    // Helper function to convert u64 to string (implementation omitted for brevity)
    fun u64_to_string(value: u64): String {
        // Implementation would convert u64 to string
        string::utf8(b"placeholder")
    }
}
```

### Unnamed Tokens with Custom Properties

Create flexible tokens with custom attributes:

```move
module movement_addr::movement_equipment_nft {
    use aptos_token_objects::token::{Self, MutatorRef, BurnRef};
    use aptos_token_objects::royalty;
    use aptos_framework::object::{Self, Object};
    use aptos_framework::event;
    use std::string::{Self, String};
    use std::option;
    use std::signer;

    /// Equipment NFT with custom properties
    struct MovementEquipment has key {
        mutator_ref: MutatorRef,
        burn_ref: BurnRef,
        equipment_type: String,
        rarity: String,
        stats: EquipmentStats,
        upgrade_level: u64,
        durability: u64,
    }

    /// Equipment statistics
    struct EquipmentStats has store, drop {
        attack: u64,
        defense: u64,
        speed: u64,
        special_ability: String,
    }

    #[event]
    struct EquipmentUpgraded has drop, store {
        token: address,
        old_level: u64,
        new_level: u64,
        new_stats: EquipmentStats,
    }

    /// Mint equipment NFT with custom properties
    public entry fun mint_equipment(
        creator: &signer,
        recipient: address,
        equipment_type: String,
        rarity: String,
        base_stats: EquipmentStats
    ) {
        let token_name = string::utf8(b"Movement Legendary Sword");
        
        let description = string::utf8(b"A legendary sword forged in the Movement realm");

        let royalty_config = royalty::create(3, 100, signer::address_of(creator));

        let constructor_ref = &token::create(
            creator,
            string::utf8(b"Movement Gaming Assets"),
            description,
            token_name,
            option::some(royalty_config),
            string::utf8(b"https://gaming.movement.xyz/equipment/sword")
        );

        // Generate refs for customization
        let mutator_ref = token::generate_mutator_ref(constructor_ref);
        let burn_ref = token::generate_burn_ref(constructor_ref);
        let token_signer = &object::generate_signer(constructor_ref);

        // Store custom equipment data
        move_to(token_signer, MovementEquipment {
            mutator_ref,
            burn_ref,
            equipment_type,
            rarity,
            stats: base_stats,
            upgrade_level: 1,
            durability: 100,
        });

        // Transfer to recipient
        let token = object::object_from_constructor_ref<token::Token>(constructor_ref);
        object::transfer(creator, token, recipient);
    }

    /// Upgrade equipment NFT
    public entry fun upgrade_equipment(
        owner: &signer,
        token: `Object<token::Token>`
    ) acquires MovementEquipment {
        let token_addr = object::object_address(&token);
        assert!(object::is_owner(token, signer::address_of(owner)), 1);
        
        let equipment = borrow_global_mut<MovementEquipment>(token_addr);
        let old_level = equipment.upgrade_level;
        
        // Upgrade stats based on level
        equipment.upgrade_level = equipment.upgrade_level + 1;
        equipment.stats.attack = equipment.stats.attack + (equipment.upgrade_level * 5);
        equipment.stats.defense = equipment.stats.defense + (equipment.upgrade_level * 3);
        equipment.stats.speed = equipment.stats.speed + (equipment.upgrade_level * 2);

        // Update token description
        let new_description = string::utf8(b"A legendary sword (Level 2) forged in the Movement realm");
        
        token::set_description(&equipment.mutator_ref, new_description);

        event::emit(EquipmentUpgraded {
            token: token_addr,
            old_level,
            new_level: equipment.upgrade_level,
            new_stats: equipment.stats,
        });
    }

    // Helper function (implementation omitted for brevity)
    fun u64_to_string(value: u64): String { string::utf8(b"placeholder") }
}
```

## Movement-Specific Features

### Gaming Integration

#### Character Progression System

NFTs that evolve based on gameplay:

```move
module movement_addr::character_progression {
    use aptos_token_objects::token::{Self, MutatorRef};
    use aptos_framework::object::{Self, Object};
    use aptos_framework::event;
    use std::string::{Self, String};
    use std::signer;
    use std::vector;

    /// Character with progression mechanics
    struct MovementCharacter has key {
        mutator_ref: MutatorRef,
        level: u64,
        experience: u64,
        class: String,
        achievements: vector<String>,
        last_battle: u64,
    }

    #[event]
    struct CharacterLevelUp has drop, store {
        character: address,
        old_level: u64,
        new_level: u64,
        new_abilities: vector<String>,
    }

    /// Gain experience and potentially level up
    public entry fun gain_experience(
        player: &signer,
        character: `Object<token::Token>`,
        exp_gained: u64
    ) acquires MovementCharacter {
        let character_addr = object::object_address(&character);
        assert!(object::is_owner(character, signer::address_of(player)), 1);
        
        let char_data = borrow_global_mut<MovementCharacter>(character_addr);
        char_data.experience = char_data.experience + exp_gained;
        
        // Check for level up (1000 exp per level)
        let new_level = char_data.experience / 1000 + 1;
        if (new_level > char_data.level) {
            let old_level = char_data.level;
            char_data.level = new_level;
            
            // Update character metadata
            let new_name = string::utf8(b"Movement Warrior (Level 5)");
            
            token::set_name(&char_data.mutator_ref, new_name);
            
            // Unlock new abilities
            let new_abilities = get_abilities_for_level(new_level);
            
            event::emit(CharacterLevelUp {
                character: character_addr,
                old_level,
                new_level,
                new_abilities,
            });
        }
    }

    // Helper functions
    fun u64_to_string(value: u64): String { string::utf8(b"placeholder") }
    fun get_abilities_for_level(level: u64): vector<String> { vector::empty() }
}
```

### DeFi Integration

#### Yield-Bearing NFTs

NFTs that generate rewards over time:

```move
module movement_addr::yield_bearing_nft {
    use aptos_token_objects::token::{Self, MutatorRef};
    use aptos_framework::fungible_asset::{Self, FungibleAsset};
    use aptos_framework::primary_fungible_store;
    use aptos_framework::object::{Self, Object};
    use aptos_framework::timestamp;
    use aptos_framework::event;
    use std::string;
    use std::signer;

    /// Yield-bearing NFT that generates Movement tokens
    struct YieldNFT has key {
        mutator_ref: MutatorRef,
        yield_rate: u64,        // Tokens per second
        last_claim: u64,        // Timestamp of last claim
        total_earned: u64,      // Total tokens earned
        boost_multiplier: u64,  // Yield boost (100 = 1x, 200 = 2x)
    }

    #[event]
    struct YieldClaimed has drop, store {
        nft: address,
        owner: address,
        amount: u64,
        total_earned: u64,
    }

    /// Claim accumulated yield from NFT
    public entry fun claim_yield(
        owner: &signer,
        nft: `Object<token::Token>`,
        reward_token_metadata: `Object<fungible_asset::Metadata>`
    ) acquires YieldNFT {
        let nft_addr = object::object_address(&nft);
        assert!(object::is_owner(nft, signer::address_of(owner)), 1);
        
        let yield_nft = borrow_global_mut<YieldNFT>(nft_addr);
        let current_time = timestamp::now_seconds();
        let time_elapsed = current_time - yield_nft.last_claim;
        
        // Calculate yield with boost
        let base_yield = time_elapsed * yield_nft.yield_rate;
        let boosted_yield = (base_yield * yield_nft.boost_multiplier) / 100;
        
        if (boosted_yield > 0) {
            // Mint reward tokens (assuming we have mint capability)
            let reward_tokens = mint_reward_tokens(boosted_yield);
            primary_fungible_store::deposit(signer::address_of(owner), reward_tokens);
            
            yield_nft.last_claim = current_time;
            yield_nft.total_earned = yield_nft.total_earned + boosted_yield;
            
            event::emit(YieldClaimed {
                nft: nft_addr,
                owner: signer::address_of(owner),
                amount: boosted_yield,
                total_earned: yield_nft.total_earned,
            });
        }
    }

    /// Apply yield boost to NFT
    public entry fun apply_yield_boost(
        owner: &signer,
        nft: `Object<token::Token>`,
        boost_percentage: u64
    ) acquires YieldNFT {
        let nft_addr = object::object_address(&nft);
        assert!(object::is_owner(nft, signer::address_of(owner)), 1);
        
        let yield_nft = borrow_global_mut<YieldNFT>(nft_addr);
        yield_nft.boost_multiplier = 100 + boost_percentage;
        
        // Update NFT metadata to reflect boost
        let boost_text = string::utf8(b" (25% Yield Boost)");
        // Update description with boost info
    }

    // Helper functions
    fun mint_reward_tokens(amount: u64): FungibleAsset {
        // Implementation would mint actual reward tokens
        abort 0
    }
    fun u64_to_string(value: u64): string::String { string::utf8(b"placeholder") }
}
```

## Token Operations

### Transfer Operations

Direct NFT transfers without opt-in requirements:

```move
public entry fun transfer_nft(
    owner: &signer,
    nft: `Object<token::Token>`,
    recipient: address
) {
    object::transfer(owner, nft, recipient);
}
```

### Batch Operations

Efficiently transfer multiple NFTs:

```move
public entry fun batch_transfer_nfts(
    owner: &signer,
    nfts: `vector<Object<token::Token>>`,
    recipients: vector<address>
) {
    let len = vector::length(&nfts);
    assert!(len == vector::length(&recipients), 1);

    let i = 0;
    while (i < len) {
        let nft = *vector::borrow(&nfts, i);
        let recipient = *vector::borrow(&recipients, i);
        object::transfer(owner, nft, recipient);
        i = i + 1;
    };
}
```

### Burning Tokens

Permanently destroy NFTs:

```move
module movement_addr::nft_burning {
    use aptos_token_objects::token::{Self, BurnRef, Token};
    use aptos_framework::object::{Self, Object};

    struct BurnableNFT has key {
        burn_ref: BurnRef,
    }

    public entry fun burn_nft(
        owner: &signer,
        nft: `Object<Token>`
    ) acquires BurnableNFT {
        let nft_addr = object::object_address(&nft);
        assert!(object::is_owner(nft, signer::address_of(owner)), 1);
        
        // Remove custom data first
        let BurnableNFT { burn_ref } = move_from<BurnableNFT>(nft_addr);
        
        // Burn the token
        token::burn(burn_ref);
    }
}
```

## Movement Token Module

For creators who want pre-built NFT functionality, Movement provides the `movement_token` module:

```move
module movement_addr::movement_token {
    use aptos_token_objects::aptos_token;
    use std::string::{Self, String};
    use std::vector;
    use aptos_framework::timestamp;
    use aptos_std::bcs;

    /// Mint a Movement-branded NFT with properties
    public entry fun mint_movement_nft(
        creator: &signer,
        collection: String,
        description: String,
        name: String,
        uri: String,
        movement_properties: vector<String>
    ) {
        let property_keys = vector[
            string::utf8(b"Movement_Ecosystem"),
            string::utf8(b"Created_On"),
            string::utf8(b"Network"),
        ];
        
        let property_types = vector[
            string::utf8(b"0x1::string::String"),
            string::utf8(b"u64"),
            string::utf8(b"0x1::string::String"),
        ];
        
        let property_values = vector[
            bcs::to_bytes(&string::utf8(b"true")),
            bcs::to_bytes(&timestamp::now_seconds()),
            bcs::to_bytes(&string::utf8(b"Movement")),
        ];

        // Add custom Movement properties
        vector::append(&mut property_keys, movement_properties);
        // Add corresponding types and values...

        aptos_token::mint(
            creator,
            collection,
            description,
            name,
            uri,
            property_keys,
            property_types,
            property_values,
        );
    }

    /// Mint soulbound Movement NFT
    public entry fun mint_soulbound_movement_nft(
        creator: &signer,
        collection: String,
        description: String,
        name: String,
        uri: String,
        soul_bound_to: address
    ) {
        let property_keys = vector[
            string::utf8(b"Movement_Soulbound"),
            string::utf8(b"Bound_To"),
        ];
        
        let property_types = vector[
            string::utf8(b"bool"),
            string::utf8(b"address"),
        ];
        
        let property_values = vector[
            bcs::to_bytes(&true),
            bcs::to_bytes(&soul_bound_to),
        ];

        aptos_token::mint_soul_bound(
            creator,
            collection,
            description,
            name,
            uri,
            property_keys,
            property_types,
            property_values,
            soul_bound_to,
        );
    }
}
```

## Query Functions

Comprehensive query interface for digital assets:

```move
// Collection queries
public fun collection_name<T: key>(collection: `Object<T>`): String
public fun collection_description<T: key>(collection: `Object<T>`): String
public fun collection_uri<T: key>(collection: `Object<T>`): String
public fun collection_creator<T: key>(collection: `Object<T>`): address

// Token queries  
public fun token_name<T: key>(token: `Object<T>`): String
public fun token_description<T: key>(token: `Object<T>`): String
public fun token_uri<T: key>(token: `Object<T>`): String
public fun token_collection<T: key>(token: `Object<T>`): `Object<collection::Collection>`

// Ownership queries
public fun owner<T: key>(object: `Object<T>`): address
public fun is_owner<T: key>(object: `Object<T>`, owner: address): bool
```

## Events and Monitoring

Movement's DA standard emits comprehensive events:

```move
// Collection events
#[event]
struct CollectionCreation has drop, store {
    creator: address,
    collection: address,
    name: String,
}

// Token events
#[event]
struct TokenMutation has drop, store {
    token: address,
    mutated_field_name: String,
}

#[event]
struct Transfer has drop, store {
    object: address,
    from: address,
    to: address,
}

#[event]
struct Burn has drop, store {
    object: address,
    previous_owner: address,
}
```

## Best Practices for Movement

### Security Considerations

- **Ref Management**: Store and protect mutator/burn refs securely
- **Access Control**: Implement proper ownership checks for sensitive operations
- **Metadata Validation**: Validate URI and description lengths
- **Custom Logic**: Audit custom resources and functionality thoroughly

### Performance Optimization

- **Batch Operations**: Use batch functions for multiple NFT operations
- **Event Efficiency**: Emit events judiciously to balance transparency and cost
- **Storage Patterns**: Use efficient data structures for NFT metadata
- **Object Lifecycle**: Plan object creation and deletion carefully

### Movement Ecosystem Integration

- **Gaming Compatibility**: Design NFTs that integrate with Movement's gaming protocols
- **DeFi Integration**: Consider yield-bearing and utility NFT mechanisms
- **Cross-Chain Features**: Plan for bridging capabilities across Movement's ecosystem
- **Governance Participation**: Enable NFTs to participate in Movement governance

### User Experience

- **Clear Metadata**: Provide comprehensive and accurate NFT information
- **Intuitive Naming**: Use clear, descriptive names for collections and tokens
- **Rich Properties**: Leverage custom properties for enhanced functionality
- **Error Handling**: Provide clear error messages for failed operations

## Migration from Legacy Standards

For projects migrating from the legacy Token standard:

1. **Assessment**: Evaluate current NFT functionality and metadata structure
2. **Mapping**: Map existing token properties to Digital Asset equivalents  
3. **Testing**: Thoroughly test migration scripts on Movement testnet
4. **Gradual Migration**: Implement phased migration to minimize user disruption
5. **User Communication**: Provide clear guidance during the transition

<Callout type="info">
Movement Labs provides comprehensive migration tools and support for projects transitioning to the Digital Asset standard. The DA standard represents the future of NFT development on Movement and offers significant advantages over legacy implementations.
</Callout>

